% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/desurv_bayesopt.R
\name{desurv_bayesopt}
\alias{desurv_bayesopt}
\title{Bayesian optimisation of DeSurv hyperparameters}
\usage{
desurv_bayesopt(
  X,
  y,
  d,
  dataset = NULL,
  samp_keeps = NULL,
  preprocess = TRUE,
  method_trans_train = c("rank", "quant", "none"),
  engine = c("cold", "warmstart"),
  bo_bounds = desurv_bo_default_bounds(),
  bo_fixed = list(),
  n_init = NULL,
  n_iter = 20,
  candidate_pool = NULL,
  exploration_weight = 0,
  seed = NULL,
  cv_verbose = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{X, y, d, dataset, samp_keeps}{Inputs forwarded to \code{\link[=desurv_cv]{desurv_cv()}}. Provide
\code{dataset}/\code{samp_keeps} only when you plan to enable preprocessing inside
cross-validation.}

\item{preprocess, method_trans_train, engine}{Arguments passed through to
\code{\link[=desurv_cv]{desurv_cv()}}. Bayesian optimisation assumes the output metric is
comparable across iterations, so keep these unchanged throughout the run.}

\item{bo_bounds}{Named list describing the search space. Each entry must be
either a numeric vector of length two (\code{c(lower, upper)}) or a list with
elements \code{lower}, \code{upper}, and optional \code{type = "continuous"}/\code{"integer"}
plus \code{scale = "linear"}/\code{"log10"}. Defaults draw from the ranges supplied
in the prompt (see \code{\link[=desurv_bo_default_bounds]{desurv_bo_default_bounds()}}).}

\item{bo_fixed}{Named list of scalar arguments that should remain constant
during optimisation (e.g., \code{lambdaW_grid = 0}, \code{lambdaH_grid = 0},
\code{nfolds = 5}). These override the defaults used in the optimiser.}

\item{n_init}{Number of Latin-hypercube evaluations before fitting the GP.
Defaults to \code{max(5, 3 * length(bo_bounds))}.}

\item{n_iter}{Number of sequential BO iterations after the initial design.}

\item{candidate_pool}{Number of random candidates assessed per acquisition
step. Defaults to \code{max(1000, 200 * length(bo_bounds))}.}

\item{exploration_weight}{Non-negative scalar \code{xi} used in the expected
improvement formula to encourage exploration.}

\item{seed}{Optional base seed for reproducibility.}

\item{cv_verbose}{Logical; if \code{TRUE}, propagate \code{verbose = TRUE} into
\code{desurv_cv()} calls. The optimiser itself still reports progress via
\code{verbose}.}

\item{verbose}{Logical; print progress after each evaluation/iteration.}

\item{...}{Additional arguments forwarded to \code{\link[=desurv_cv]{desurv_cv()}} (for example
\code{seed}, \code{folds}, or \code{parallel_grid}).}
}
\value{
An object of class \code{desurv_bo} containing:
\itemize{
\item \code{history}: data frame of every evaluation (parameters, score, status).
\item \code{best}: list with \code{params} (named numeric vector) and
\code{mean_cindex}.
\item \code{bounds}: parsed search-space specification.
\item \code{fixed}: fixed hyperparameters supplied through \code{bo_fixed}.
\item \code{seed}: RNG seed used internally.
\item \code{call}: original function call.
}
}
\description{
Sequentially tunes the scalar inputs to \code{\link[=desurv_cv]{desurv_cv()}} with a simple Gaussian
process surrogate and expected-improvement acquisition rule. Each evaluation
runs \code{desurv_cv(cv_only = TRUE)} for a single hyperparameter combination, so
the optimisation surface is defined by the resulting mean validation
C-index. The routine always maximises the C-index.
}
\details{
This helper relies on the \code{DiceKriging} and \code{lhs} packages for Gaussian
process modelling and Latin hypercube sampling. They are listed under
\code{Suggests}; an informative error is thrown if they are not installed.
}
\examples{
\dontrun{
data <- readRDS("data.rds")
bo_fit <- desurv_bayesopt(
  X = data$ex,
  y = data$sampInfo$time,
  d = data$sampInfo$event,
  dataset = data$sampInfo$dataset,
  samp_keeps = data$samp_keeps,
  preprocess = TRUE,
  method_trans_train = "rank",
  engine = "cold",
  bo_bounds = desurv_bo_default_bounds(include_factor_penalties = FALSE),
  bo_fixed = list(lambdaW_grid = 0, lambdaH_grid = 0, nfolds = 5),
  n_init = 12,
  n_iter = 25,
  candidate_pool = 2000,
  exploration_weight = 0.01,
  seed = 2025,
  verbose = TRUE
)
print(bo_fit)
}

}
\seealso{
\code{\link[=desurv_cv]{desurv_cv()}}, \code{\link[=desurv_bo_default_bounds]{desurv_bo_default_bounds()}}
}
